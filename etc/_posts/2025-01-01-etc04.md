---
layout: post
title: etc04
sitemap: false
hide_last_modified: true
---
# MVCC

* toc
{:toc .large-only}

# 다중 버전 동시성 제어
다중 버전 동시성 제어`MVCC(Multi-Version Concurrency Control)`란, DBMS의 동시성 제어 메커니즘으로 트랜잭션 격리 수준을 구현하는 방법 중 하나이다.
MVCC는 `스냅샷`과 `버전`이라는 개념으로 데이터베이스의 동시성과 일관성을 유지하는데, 간단히 설명하자면 `스냅샷`은 트랜잭션 시작 시점의 DB상태를 캡처한 것이고, `버전`은 데이터 변경 이력을 뜻한다.  

## MVCC의 동작
MVCC는 트랜잭션의 스냅샷과 버전을 기반으로 동시 접근 시 충돌을 방지하여 데이터 중복 방지와 일관성을 보장하며,  
두 트랜잭션(txA와 txB)이 동시에 작업을 수행할 경우, 먼저 커밋된 트랜잭션의 데이터를 최종적으로 반영한다.
대표적으로 MySQL(InnoDB), PostgreSQL에서 사용되며, MySQL (MyISAM), Oracle Database등에서는 사용하지 않는다.

> MySQL 엔진 (InnoDB / MyISAM): 데이터를 저장하고 관리하는 방식을 정의하는 MySQL의 구성요소 (일종의 정책).  
> 테이블 생성 시 엔진을 명시적으로 설정 가능.

## 스냅샷과 버전의 동작 원리
-  txA와 txB가 동시에 접근하는 상황을 가정한다.
- 데이터의 초기상태는 버전 0이다.

|ID|Name|
|:--:|:--:|
|1|Jason|

1. txA가 자신이 갖고 있는 스냅샷(트랜잭션 시작 시점의 데이터 - 버전0)에서 UPDATE를 실행하여 데이터를 "Alpha"로 변경.
2. txA가 커밋을 실행하여 버전 1이 생성.  
  2-1. MVCC가 없다면 데이터 커밋 전에도 `Alpha`로 조회됨.
3. txB가 UPDATE를 실행하여 데이터를 "Bravo"로 변경.
4. txB가 커밋을 시도하면, 버전 1과 충돌을 감지하여 커밋이 실패.
5. 최종 데이터는 `txA가 수정한 Alpha`로 유지.

트랜잭션 시작 시점의 데이터를 스냅샷으로 보장함으로써, Dirty Read와 Unrepeatable Read를 방지한다.

### 참고
- Dirty Read: 커밋되지 않은 데이터를 읽음
- Unrepeatable Read: 데이터 반복 조회 시 다른 트랜잭션에서 값을 수정하여 조회 값이 달라짐(다른 트랜잭션에서 데이터가 수정됨)

[트랜잭션 이상현상](https://xxyoonxx.github.io/etc/2024-12-30-etc03/#%EC%A3%BC%EC%9A%94-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%9D%B4%EC%83%81)

## 장점
- 읽기 - 쓰기의 동시성 보장
  - 읽기 작업 시 별도의 스냅샷을 참조하므로 하나의 트랜잭션이 쓰기 작업이 진행 중이어도 다른 트랜잭션이 읽기 작업 가능.
- 교착 상태를 방지
  - MVCC가 없다면 락 기반으로 이를 제어하게 되는데 단순 조회라도 다른 트랜잭션의 작업을 기다려야한다. 때문에 동시성이 낮아지고 교착상태가 발생 할 수 있으며 성능이 떨어진다.
- 데이터 작업 중 값이 수정되지 않음
  - 각자의 스냅샷을 가지고 독립적인 공간에서 작업하므로 내가 작업하는 동안 다른 트랜잭션이 데이터를 수정해서 커밋해도, 내 트랜잭션에서는 여전히 기존 값을 반환한다.
  - 실시간으로 변동되는 정보 중 일부를 가지고 작업 할 때 유리(주식 구매와 같은 실시간 금융 거래 시스템 등)

## 단점
- 데이터의 버전이 여러 개 생길 경우 스토리지 사용량 증가
- 스냅샷 기반으로 작업하므로 다른 트랜잭션이 작업한 최신 데이터의 반영이 지연 될 수 있음
- 여러 트랜잭션이 같은 데이터 수정 시 커밋이 늦은 트랜잭션에서 롤백이 발생하므로 성능 저하 가능성 있음

## 트랜잭션 격리 수준과 MVCC의 관계
MVCC는 트랜잭션 격리 수준에 따라 스냅샷 생성 시점과 데이터 접근 방식을 조정한다.  
트랜잭션 격리 수준이 높아질 수록 MVCC가 더 많은 제약을 적용하게 된다.