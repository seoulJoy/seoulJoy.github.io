---
layout: post
title: etc05
sitemap: false
hide_last_modified: true
---
# 소프트웨어 아키텍처 패턴

* toc
{:toc .large-only}

# 소프트웨어 아키텍처 패턴이란?
우선 소프트웨어 아키텍처란, 소프트웨어 `기본 구성`를 설계하는 설계도의 개념이다. 
기본 구성에는 시스템 구성요소들과 이들 간의 상호작용 방법, 상호 의존성 등이 포함된다.

나아가 소프트웨어 아키텍처 패턴이란, 이 소프트웨어 아키텍처를 설계할 때 자주 마주할 수 있는 문제들을 해결하기 위해 `패턴화`를 한 것을 뜻한다.
패턴화 된 아키텍처를 사용하면 많은 선례를 통해 자주 발생하는 문제들을 사전에 방지해서 효율성을 향상시킬 수 있고, 뼈대가 표준화 되어있으며, 리스크를 줄일 수 있다.

## 대표적인 소프트웨어 아키텍처
### 계층형 아키텍처 (Layered Architecture)
애플리케이션을 프레젠테이션 > 비즈니스 로직 > 데이터 접근과 같은 `수직계층`으로 나눈다.  
각 계층은 자신보다 하위 계층만 참조하며, 자신보다 상위 계층을 참조하지 않는다.  

- 구조
  - Presentation Layer: UI
  - Application Layer: 서비스 로직
  - Domain Layer: 핵심 비즈니스 로직
  - Infrastructure Layer: DB, 외부 시스템

보편적으로 쓰이는 아키텍처인 만큼 간단하고 익숙하지만, 도메인이 확장 될 수록 계층 간 강한 결합이 생길 수 있어 확장성은 떨어지는 편이다.
보통 중소규모 프로젝트에서 많이 사용한다.

### 헥사고날 아키텍처
소프트웨어의 비즈니스 로직을 외부 시스템에서 분리시키기 위해 고안되었다.  
`포트`와 `어댑터`를 이용해 내부/외부의 독립성 및 확장성 향상을 목표로 한다.
외부 시스템과의 연결 및 통합이 많을 때 유리하다.

- 구조
  - Core: 시스템의 핵심 비즈니스 규칙과 유스케이스를 포함
  - Ports: 내부와 외부를 연결해주는 인터페이스
  ```java
  public interface UserRepository {
    void save(User user);
    User findById(Long id);
  }
  ```
  - Adapters: `Ports`를 구현하여 외부와 상호작용
  ```java
  @Repository
  public class JpaUserRepository implements UserRepository {
      @Override
      public void save(User user) {
          // JPA를 통해 DB에 저장
          System.out.println("User saved to the database: " + user.getName());
      }

      @Override
      public User findById(Long id) {
          // JPA를 통해 DB에서 조회
          System.out.println("Finding user by ID: " + id);
          return new User(id, "John Doe"); // 임의의 데이터 반환
      }
  }
  ```

인터페이스를 이용해 외부 연결을 추상화를 해야하므로 불필요한 추상화가 늘어날 가능성이 있고, 초기 설계 및 구현의 복잡도가 높으며 시간이 많이 소요 될 수 있다.  


### 클린 아키텍처 (Clean Architecture)
헥사고날 아키텍처에서 발전된 개념으로, 헥사고날 아키텍처보다 도메인 중심적이다.
비즈니스 로직을 포함하는 내부계층이 `외부 인터페이스 및 프레임워크`에 독립적이어서 테스트와 기술 교체에 자유롭다.  
내부 계층은 외부계층과의 연결을 `interface`를 통해 추상화 하여 독립성을 유지한다.

- 구조
  - Entities: 핵심 비즈니스 규칙 (Domain Layer)
  - Use Cases: 애플리케이션의 유스케이스 및 비즈니스 로직
  - Interface Adapters: 외부 세계(UI, DB, API 등)와 내부 Use Cases 간 변환 로직
  - Frameworks & Drivers: 프레임워크, 데이터베이스, 외부 시스템과의 통신

헥사고날 아키텍처의 단점을 모두 가져갈 뿐더러 계층 구조가 엄격히 구분되어 있다보니 작은 애플리케이션에도 과도한 설계가 들어갈 수 있고, 구현 시간이 늘어 날 수 있다.  
또한 이로 인해 테스트 코드의 복잡성도 증가할 가능성이 있다.

### 마이크로서비스 아키텍처
단일 애플리케이션을 독립 서비스로 분리하여 설계하는 아키텍처이다. 비즈니스 요구사항, 운영 효율성 등에 따라 서비스 분리 기준이 달라진다.  
각 서비스는 고유한 도메인과 책임을 가지며 서로 독립적으로 배포/확장이 가능하다.  

- 구조
  - Domain Service: 각 서비스의 비즈니스 로직 담당
  - API Gateway: 클라이언트와 서비스 간의 요청 라우팅
  - Messaging System: 서비스 간 비동기 통신 지원 (이벤트 기반 통신)
  - Database Per Service: 각 서비스가 독립적으로 데이터를 관리

서비스 간 데이터 동기화 문제가 발생 할 수 있으며 서비스 분리와 통신 구조 설계의 복잡성이 높다.
또한 운영 시 모니터링, 네트워크 관리 등에 추가적인 비용이 들 수 있다.

### 이벤트 기반 아키텍처
시스템 내에서 발생하는 이벤트를 중심으로 통신이 이루어진다.
이벤트는 특정 상태 변경이나 작업 완료를 나타내며, 이를 기반으로 여러 구성 요소가 반응한다.  
주로 비동기 처리가 중요한 애플리케이션(주문 처리, 알림 서비스 등)에 많이 쓰이며, 단독으로는 잘 사용하지 않는 편이다.  

- 구조
  - Event Producer: 이벤트를 생성하고 브로커에 전달.
  - Event Broker: 이벤트를 전달하고, 구독자와 생산자를 연결.
  - Event Consumer: 이벤트를 구독하고 작업 실행.

이벤트 흐름의 추적 및 디버깅이 어렵고, 메시지 브로커에 대한 의존성이 높기 때문에 장애 발생 시 그 리스크 및 복구가 다른 아키텍처보다 복잡한 편이다.

### CQRS + 이벤트 소싱
CQRS란 명령과 조회 작업을 분리하여 데이터 처리 성능을 최적화하는 패턴이다.  
이벤트 소싱이란 데이터의 변경 사항을 이벤트를 이용해 저장하는 것을 말한다.

- 구조
  - Write Model: Command 처리를 위한 비즈니스 로직 포함
  - Read Model: Query 최적화를 위한 데이터 모델
  - Event Store: 이벤트를 저장하고, 상태를 복원 가능

#### 참고: 이벤트 소싱 & 이벤트 기반 아키텍처
- 이벤트 소싱: 데이터를 이벤트로 저장해서 상태변경을 관리
- 이벤트 기반 아키텍처: 메시지 브로커를 이용한 이벤트를 이용해서 시스템 간 통신

## 현업에서의 선택 기준
- 프로젝트 규모
  - 소규모: 레이어드 아키텍처
  - 대규모: 마이크로서비스, 클린 아키텍처
- 도메인 복잡성
  - 단순 CRUD 애플리케이션: 레이어드 아키텍처
  - 복잡한 도메인 규칙: 클린 아키텍처, 헥사고날 아키텍처
- 기술 요구사항
  - 이벤트 기반: 이벤트 드리븐 아키텍처
  - 클라우드 최적화: 서버리스 아키텍처
